// Generated by CoffeeScript 1.6.2
(function() {
  var BindableSetter, Binding, bindableSetter, deepPropertyWatcher, options, toarray, type, utils,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  BindableSetter = require("./setters/factory");

  bindableSetter = new BindableSetter();

  utils = require("../core/utils");

  options = require("../utils/options");

  toarray = require("toarray");

  deepPropertyWatcher = require("./deepPropertyWatcher2");

  type = require("type-component");

  /*
   Glues stuff together
  */


  module.exports = Binding = (function() {
    /*
    */
    Binding.prototype.__isBinding = true;

    /*
    */


    function Binding(_from, properties) {
      this._from = _from;
      this._onChange = __bind(this._onChange, this);
      this._properties = type(properties) === "string" ? properties.split(/[,\s]+/g) : properties;
      this._limit = -1;
      this._delay = options.delay;
      this._setters = [];
      this._cvalues = [];
      this._listeners = [];
      this._triggerCount = 0;
      this._listen();
    }

    /*
    */


    Binding.prototype._values = function() {
      var i, listener, v, _i, _len, _ref;

      _ref = this._listeners;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        listener = _ref[i];
        v = listener.value();
        if (v !== this._cvalues[i]) {
          this._cvalues[i] = v;
        }
      }
      return this._cvalues;
    };

    /* 
     executes the binding now
    */


    Binding.prototype.now = function(value) {
      return this._onChange(this._values());
    };

    /*
     casts this binding as a collection binding
    */


    Binding.prototype.collection = function() {
      if (this._collectionBinding) {
        return this._collectionBinding;
      }
      this._collection = new Binding.Collection();
      this.to(this._collection.source);
      this.now();
      return this._collectionBinding = this._collection.bind().copyId(true);
    };

    /*
     binds to a target
    */


    Binding.prototype.to = function(target, property, now) {
      var setter;

      if (now == null) {
        now = false;
      }
      setter = bindableSetter.createSetter(this, target, property);
      if (setter) {
        this._setters.push(setter);
        if (now === true) {
          setter.now();
        }
      }
      return this;
    };

    /*
     from property? create a binding going the other way. This is useful for classes. see class-test.js
    */


    Binding.prototype.from = function(from, property) {
      if (arguments.length === 1) {
        property = from;
        from = this._from;
      }
      return from.bind(property).to(this._from, this._properties);
    };

    /*
     DEPRECATED - use map
    */


    Binding.prototype.transform = function(options) {
      return this.map.apply(this, arguments);
    };

    /*
    */


    Binding.prototype.map = function(options) {
      if (!arguments.length) {
        return this._map;
      }
      this._map = utils.transformer(options);
      return this;
    };

    /*
    */


    Binding.prototype._transformer = function() {
      return this._transform || (this._transform = utils.transformer(options));
    };

    /*
     runs the binding just once
    */


    Binding.prototype.once = function() {
      return this.limit(1);
    };

    /*
     limits the number of times the binding can be called
    */


    Binding.prototype.limit = function(count) {
      this._limit = count;
      return this;
    };

    /*
     returns whether the binding is bound with ways
    */


    Binding.prototype.isBothWays = function() {
      return !!this._boundBothWays;
    };

    /*  
     makes the binding go both ways.
    */


    Binding.prototype.bothWays = function() {
      var setter, _i, _len, _ref;

      if (this._boundBothWays) {
        return this;
      }
      this._boundBothWays = true;
      _ref = this._setters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        setter = _ref[_i];
        setter.bothWays();
      }
      return this;
    };

    /*
    */


    Binding.prototype.delay = function(value) {
      if (!arguments.length) {
        return this._delay;
      }
      this._delay = value;
      return this;
    };

    /*
     removes the binding
    */


    Binding.prototype.dispose = function() {
      var disposeListener, listener, setter, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;

      _ref = this._setters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        setter = _ref[_i];
        setter.dispose();
      }
      this._setters = [];
      if (this._collectionBinding) {
        this._collectionBinding.dispose();
      }
      if (this._listeners) {
        _ref1 = this._listeners;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          listener = _ref1[_j];
          listener.dispose();
        }
        _ref2 = this._disposeListeners;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          disposeListener = _ref2[_k];
          disposeListener.dispose();
        }
      }
      this._listener = void 0;
      this._disposeListener = void 0;
      return this;
    };

    /*
    */


    Binding.prototype._listen = function() {
      var disposeListeners, listeners, property, _i, _len, _ref,
        _this = this;

      listeners = [];
      disposeListeners = [];
      _ref = this._properties;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        property = _ref[_i];
        listeners.push(deepPropertyWatcher.create({
          target: this._from,
          path: property.split("."),
          callback: this._onChange,
          index: 0,
          delay: this._delay
        }));
        disposeListeners.push(this._from.once("dispose", function() {
          return _this.dispose();
        }));
      }
      this._disposeListeners = disposeListeners;
      return this._listeners = listeners;
    };

    /*
    */


    Binding.prototype._onChange = function(value) {
      var setter, values, _i, _len, _ref;

      values = this._values();
      if (!values.length) {
        return this;
      }
      _ref = this._setters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        setter = _ref[_i];
        setter.change(values);
      }
      if (~this._limit && ++this._triggerCount >= this._limit) {
        this.dispose();
      }
      return this;
    };

    return Binding;

  })();

  /*
  */


  Binding.fromOptions = function(target, options) {
    var binding, t, to, tops, _i, _len, _ref;

    binding = target.bind(options.from || options.property);
    if (type(options.to) === "object") {
      for (to in options.to) {
        tops = options.to[to];
        if (tops.transform || tops.map) {
          binding.map(tops.transform || tops.map);
        }
        if (tops.now) {
          binding.now();
        }
        if (tops.bothWays) {
          binding.bothWays();
        }
        binding.to(to);
      }
    } else {
      options.to = toarray(options.to);
      _ref = options.to;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        tops = typeof t === "object" ? t : {
          property: t
        };
        if (tops.transform || tops.map) {
          bindings.map(tops.transform || tops.map);
        }
        binding.to(tops.property);
      }
    }
    if (options.limit) {
      binding.limit(options.limit);
    }
    if (options.once) {
      binding.once();
    }
    if (options.bothWays) {
      binding.bothWays();
    }
    if (options.now) {
      binding.now();
    }
    return binding;
  };

}).call(this);
