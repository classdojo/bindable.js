// Generated by CoffeeScript 1.6.2
(function() {
  var BindableSetter, Binding, bindableSetter, deepPropertyWatcher, toarray, type, utils,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  BindableSetter = require("./setters/factory");

  bindableSetter = new BindableSetter();

  utils = require("../core/utils");

  toarray = require("toarray");

  deepPropertyWatcher = require("./deepPropertyWatcher2");

  type = require("type-component");

  /*
   Glues stuff together
  */


  module.exports = Binding = (function() {
    /*
    */
    Binding.prototype.__isBinding = true;

    /*
    */


    function Binding(_from, _property) {
      this._from = _from;
      this._property = _property;
      this._onChange = __bind(this._onChange, this);
      this._limit = -1;
      this._setters = [];
      this._triggerCount = 0;
      this._listen();
    }

    /* 
     executes the binding now
    */


    Binding.prototype.now = function(value) {
      return this._onChange(this._listener.value());
    };

    /*
     casts this binding as a collection binding
    */


    Binding.prototype.collection = function() {
      if (this._collectionBinding) {
        return this._collectionBinding;
      }
      this._collection = new Binding.Collection();
      this.to(this._collection.source);
      this.now();
      return this._collectionBinding = this._collection.bind().copyId(true);
    };

    /*
     binds to a target
    */


    Binding.prototype.to = function(target, property, now) {
      var setter;

      if (now == null) {
        now = false;
      }
      setter = bindableSetter.createSetter(this, target, property);
      if (setter) {
        this._setters.push(setter);
        if (now === true) {
          setter.now();
        }
      }
      return this;
    };

    /*
     from property? create a binding going the other way. This is useful for classes. see class-test.js
    */


    Binding.prototype.from = function(from, property) {
      if (arguments.length === 1) {
        property = from;
        from = this._from;
      }
      return from.bind(property).to(this._from, this._property);
    };

    /*
     DEPRECATED - use map
    */


    Binding.prototype.transform = function(options) {
      return this.map.apply(this, arguments);
    };

    /*
    */


    Binding.prototype.map = function(options) {
      if (!arguments.length) {
        return this._map;
      }
      this._map = utils.transformer(options);
      return this;
    };

    /*
    */


    Binding.prototype._transformer = function() {
      return this._transform || (this._transform = utils.transformer(options));
    };

    /*
     runs the binding just once
    */


    Binding.prototype.once = function() {
      return this.limit(1);
    };

    /*
     limits the number of times the binding can be called
    */


    Binding.prototype.limit = function(count) {
      this._limit = count;
      return this;
    };

    /*
     returns whether the binding is bound with ways
    */


    Binding.prototype.isBothWays = function() {
      return !!this._boundBothWays;
    };

    /*  
     makes the binding go both ways.
    */


    Binding.prototype.bothWays = function() {
      var setter, _i, _len, _ref;

      if (this._boundBothWays) {
        return this;
      }
      this._boundBothWays = true;
      _ref = this._setters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        setter = _ref[_i];
        setter.bothWays();
      }
      return this;
    };

    /*
     removes the binding
    */


    Binding.prototype.dispose = function() {
      var setter, _i, _len, _ref;

      _ref = this._setters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        setter = _ref[_i];
        setter.dispose();
      }
      this._setters = [];
      if (this._collectionBinding) {
        this._collectionBinding.dispose();
      }
      if (this._listener) {
        this._listener.dispose();
        this._disposeListener.dispose();
      }
      this._listener = void 0;
      this._disposeListener = void 0;
      return this;
    };

    /*
    */


    Binding.prototype._listen = function() {
      var _this = this;

      this._listener = deepPropertyWatcher.create({
        target: this._from,
        path: this._property.split("."),
        callback: this._onChange,
        index: 0,
        watchIndex: 0
      });
      return this._disposeListener = this._from.once("dispose", function() {
        return _this.dispose();
      });
    };

    /*
    */


    Binding.prototype._onChange = function(value) {
      var setter, _i, _len, _ref, _ref1;

      value = (_ref = this._listener) != null ? _ref.value() : void 0;
      if (this.value === value) {
        return this;
      }
      this.value = value;
      _ref1 = this._setters;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        setter = _ref1[_i];
        setter.change(value);
      }
      if (~this._limit && ++this._triggerCount >= this._limit) {
        this.dispose();
      }
      return this;
    };

    return Binding;

  })();

  /*
  */


  Binding.fromOptions = function(target, options) {
    var binding, t, to, tops, _i, _len, _ref;

    binding = target.bind(options.from || options.property);
    if (type(options.to) === "object") {
      for (to in options.to) {
        tops = options.to[to];
        if (tops.transform || tops.map) {
          binding.map(tops.transform || tops.map);
        }
        if (tops.now) {
          binding.now();
        }
        if (tops.bothWays) {
          binding.bothWays();
        }
        binding.to(to);
      }
    } else {
      options.to = toarray(options.to);
      _ref = options.to;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        tops = typeof t === "object" ? t : {
          property: t
        };
        if (tops.transform || tops.map) {
          bindings.map(tops.transform || tops.map);
        }
        binding.to(tops.property);
      }
    }
    if (options.limit) {
      binding.limit(options.limit);
    }
    if (options.once) {
      binding.once();
    }
    if (options.bothWays) {
      binding.bothWays();
    }
    if (options.now) {
      binding.now();
    }
    return binding;
  };

}).call(this);
